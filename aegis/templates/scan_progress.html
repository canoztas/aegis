{% extends "base.html" %}

{% block title %}Scan Progress - aegis{% endblock %}

{% block head %}
<style>
  .progress-container {
    max-width: 1200px;
    margin: 0 auto;
  }

  .progress-header {
    margin-bottom: 2rem;
  }

  .progress-main {
    margin-bottom: 2rem;
  }

  .progress-bar-container {
    height: 8px;
    background-color: var(--bg-tertiary);
    border-radius: 4px;
    overflow: hidden;
    margin-bottom: 0.5rem;
  }

  .progress-bar-fill {
    height: 100%;
    background: linear-gradient(90deg, #58a6ff 0%, #4dabf7 100%);
    transition: width 0.3s ease;
    width: 0%;
  }

  .progress-stats {
    display: flex;
    gap: 2rem;
    font-size: 0.875rem;
    color: var(--text-secondary);
  }

  .step-indicator {
    display: flex;
    align-items: center;
    gap: 1rem;
    margin-bottom: 1rem;
  }

  .step-icon {
    width: 32px;
    height: 32px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.875rem;
    flex-shrink: 0;
  }

  .step-icon.pending {
    background-color: var(--bg-tertiary);
    color: var(--text-secondary);
  }

  .step-icon.running {
    background-color: #58a6ff;
    color: white;
    animation: pulse 2s ease-in-out infinite;
  }

  .step-icon.completed {
    background-color: #3fb950;
    color: white;
  }

  .step-icon.failed {
    background-color: #f85149;
    color: white;
  }

  .step-icon.skipped {
    background-color: #8b949e;
    color: white;
  }

  @keyframes pulse {

    0%,
    100% {
      opacity: 1;
    }

    50% {
      opacity: 0.7;
    }
  }

  .step-details {
    flex: 1;
  }

  .step-name {
    font-weight: 600;
    margin-bottom: 0.25rem;
  }

  .step-meta {
    font-size: 0.875rem;
    color: var(--text-secondary);
  }

  .model-panel {
    background-color: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 6px;
    padding: 1rem;
    margin-bottom: 1rem;
  }

  .model-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 0.75rem;
  }

  .model-name {
    font-weight: 600;
    font-size: 0.875rem;
  }

  .model-status {
    font-size: 0.75rem;
    padding: 0.25rem 0.5rem;
    border-radius: 4px;
    font-weight: 500;
  }

  .model-status.running {
    background-color: rgba(88, 166, 255, 0.2);
    color: #58a6ff;
  }

  .model-status.completed {
    background-color: rgba(63, 185, 80, 0.2);
    color: #3fb950;
  }

  .model-status.downloading {
    background-color: rgba(88, 166, 255, 0.2);
    color: #58a6ff;
    animation: pulse 2s ease-in-out infinite;
  }

  .model-stats {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
    gap: 0.75rem;
    font-size: 0.875rem;
  }

  .model-stat {
    display: flex;
    flex-direction: column;
  }

  .model-stat-label {
    color: var(--text-secondary);
    font-size: 0.75rem;
    margin-bottom: 0.25rem;
  }

  .model-stat-value {
    font-weight: 600;
    font-family: var(--font-mono, 'JetBrains Mono'), monospace;
  }

  .findings-stream {
    background-color: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 6px;
    padding: 1rem;
    max-height: 400px;
    overflow-y: auto;
  }

  .findings-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1rem;
    padding-bottom: 0.5rem;
    border-bottom: 1px solid var(--border-color);
  }

  .findings-count {
    font-weight: 600;
    color: var(--accent-color);
  }

  .finding-item {
    padding: 0.75rem;
    margin-bottom: 0.5rem;
    background-color: var(--bg-tertiary);
    border-left: 3px solid;
    border-radius: 4px;
    font-size: 0.875rem;
    animation: slideIn 0.3s ease-out;
  }

  @keyframes slideIn {
    from {
      opacity: 0;
      transform: translateY(-10px);
    }

    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  .finding-item.severity-critical {
    border-left-color: #f85149;
  }

  .finding-item.severity-high {
    border-left-color: #ff8800;
  }

  .finding-item.severity-medium {
    border-left-color: #d29922;
  }

  .finding-item.severity-low {
    border-left-color: #3fb950;
  }

  .finding-name {
    font-weight: 600;
    margin-bottom: 0.25rem;
  }

  .finding-meta {
    color: var(--text-secondary);
    font-size: 0.75rem;
  }

  .activity-log {
    background-color: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 6px;
    padding: 1rem;
    max-height: 300px;
    overflow-y: auto;
    font-family: var(--font-mono, 'JetBrains Mono'), monospace;
    font-size: 0.75rem;
  }

  .log-entry {
    padding: 0.25rem 0;
    color: var(--text-secondary);
  }

  .log-entry.info {
    color: #58a6ff;
  }

  .log-entry.success {
    color: #3fb950;
  }

  .log-entry.warning {
    color: #d29922;
  }

  .log-entry.error {
    color: #f85149;
  }

  .log-timestamp {
    color: var(--text-secondary);
    margin-right: 0.5rem;
  }

  .status-badge {
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.5rem 1rem;
    border-radius: 6px;
    font-weight: 600;
    font-size: 0.875rem;
  }

  .status-badge.running {
    background-color: rgba(88, 166, 255, 0.2);
    color: #58a6ff;
  }

  .status-badge.completed {
    background-color: rgba(63, 185, 80, 0.2);
    color: #3fb950;
  }

  .status-badge.failed {
    background-color: rgba(248, 81, 73, 0.2);
    color: #f85149;
  }

  .status-badge.cancelled {
    background-color: rgba(210, 153, 34, 0.2);
    color: #d29922;
  }

  .control-buttons {
    display: flex;
    gap: 0.5rem;
  }

  .empty-state {
    text-align: center;
    padding: 2rem;
    color: var(--text-secondary);
  }

  .spinner {
    display: inline-block;
    width: 14px;
    height: 14px;
    border: 2px solid currentColor;
    border-right-color: transparent;
    border-radius: 50%;
    animation: spin 0.75s linear infinite;
  }

  @keyframes spin {
    to {
      transform: rotate(360deg);
    }
  }
</style>
{% endblock %}

{% block content %}
<div class="container mt-4 progress-container">
  <!-- Header -->
  <div class="progress-header">
    <div class="d-flex justify-content-between align-items-start">
      <div>
        <h2>Scan Progress</h2>
        <p class="text-muted mb-0">Scan ID: <code id="scanId">{{ scan_id }}</code></p>
      </div>
      <div>
        <span id="statusBadge" class="status-badge running">
          <span class="spinner"></span>
          Running
        </span>
      </div>
    </div>
  </div>

  <!-- Overall Progress -->
  <div class="card mb-4">
    <div class="card-body">
      <h5 class="card-title mb-3">Overall Progress</h5>
      <div class="progress-bar-container">
        <div id="progressBar" class="progress-bar-fill"></div>
      </div>
      <div class="progress-stats">
        <span><strong id="progressPercent">0</strong>% complete</span>
        <span id="progressMessage" class="fw-bold text-primary font-monospace">Initializing...</span>
        <span id="progressTime">Elapsed: <strong>0s</strong></span>
      </div>
    </div>
  </div>

  <div class="row">
    <!-- Left Column: Steps & Models -->
    <div class="col-lg-6">
      <!-- Pipeline Steps -->
      <div class="card mb-4">
        <div class="card-body">
          <h5 class="card-title mb-3">Pipeline Steps</h5>
          <div id="stepsContainer">
            <div class="empty-state">
              <p>Waiting for pipeline to start...</p>
            </div>
          </div>
        </div>
      </div>

      <!-- Model Telemetry -->
      <div class="card mb-4">
        <div class="card-body">
          <h5 class="card-title mb-3">Model Telemetry</h5>
          <div id="modelsContainer">
            <div class="empty-state">
              <p>No model data yet</p>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Right Column: Findings & Log -->
    <div class="col-lg-6">
      <!-- Live Findings -->
      <div class="card mb-4">
        <div class="card-body p-0">
          <div class="findings-stream">
            <div class="findings-header">
              <h5 class="mb-0">Live Findings</h5>
              <span class="findings-count"><span id="findingsCount">0</span> findings</span>
            </div>
            <div id="findingsContainer">
              <div class="empty-state">
                <p>No findings yet</p>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Activity Log -->
      <div class="card">
        <div class="card-body p-0">
          <div class="activity-log" id="activityLog">
            <div class="log-entry info">
              <span class="log-timestamp">--:--:--</span>
              <span>Connecting to scan stream...</span>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Control Buttons -->
  <div class="card mt-4">
    <div class="card-body">
      <div class="control-buttons">
        <a href="{{ url_for('main.index') }}" class="btn btn-outline-secondary">
          <i class="bi bi-arrow-left"></i> Back to Home
        </a>
        <button id="viewResultsBtn" class="btn btn-primary" disabled>
          <i class="bi bi-file-text"></i> View Results
        </button>
        <button id="cancelScanBtn" class="btn btn-outline-danger" style="display: none;">
          <i class="bi bi-x-circle"></i> Cancel Scan
        </button>
      </div>
    </div>
  </div>
</div>
{% endblock %}

{% block scripts %}
<script>
  // SSE Client for Real-Time Progress
  (function () {
    'use strict';

    const scanId = '{{ scan_id }}';
    let startTime = Date.now();
    let eventSource = null;
    let findingsCount = 0;
    let steps = {};
    let models = {};
    let statusPollTimer = null;
    let terminalStatus = null;

    function updateLocalStatus(status) {
      try {
        localStorage.setItem("aegis_last_scan_id", scanId);
        localStorage.setItem("aegis_last_scan_status", status);
      } catch (e) {
        // Ignore storage errors
      }
    }

    function startStatusPolling() {
      if (statusPollTimer) {
        return;
      }
      statusPollTimer = setInterval(checkStatus, 10000);
      checkStatus();
    }

    function stopStatusPolling() {
      if (statusPollTimer) {
        clearInterval(statusPollTimer);
        statusPollTimer = null;
      }
    }

    async function checkStatus() {
      if (terminalStatus) {
        return;
      }
      try {
        const response = await fetch(`/api/scan/${scanId}/status`, { cache: "no-store" });
        if (!response.ok) {
          return;
        }
        const data = await response.json();
        const status = data && data.status;

        if (data.started_at) {
          startTime = new Date(data.started_at).getTime();
        }

        if (status === "completed") {
          onCompleted({});
        } else if (status === "failed") {
          onError("Scan failed");
        } else if (status === "cancelled") {
          onCancelled("Scan cancelled");
        }
      } catch (error) {
        // Ignore polling errors to avoid noisy UI
      }
    }

    // Initialize SSE connection
    function initSSE() {
      updateLocalStatus("pending");
      const url = `/api/scan/${scanId}/stream`;
      eventSource = new EventSource(url);

      // Event handlers
      eventSource.addEventListener('connected', handleConnected);
      eventSource.addEventListener('pipeline_started', handlePipelineStarted);
      eventSource.addEventListener('step_start', handleStepStart);
      eventSource.addEventListener('step_completed', handleStepCompleted);
      eventSource.addEventListener('step_skipped', handleStepSkipped);
      eventSource.addEventListener('step_failed', handleStepFailed);
      eventSource.addEventListener('model_downloading', handleModelDownloading);
      eventSource.addEventListener('model_start', handleModelStart);
      eventSource.addEventListener('model_completed', handleModelCompleted);
      eventSource.addEventListener('progress', handleProgress);
      eventSource.addEventListener('cancelled', handleCancelled);
      eventSource.addEventListener('finding', handleFinding);
      eventSource.addEventListener('warning', handleWarning);
      eventSource.addEventListener('completed', handleCompleted);
      eventSource.addEventListener('error', handleError);

      // Cascade-specific events
      eventSource.addEventListener('cascade_pass_started', handleCascadePassStarted);
      eventSource.addEventListener('cascade_pass_completed', handleCascadePassCompleted);
      eventSource.addEventListener('cascade_pass_skipped', handleCascadePassSkipped);

      eventSource.onerror = function (e) {
        logMessage('Connection error, retrying...', 'error');
        // EventSource will auto-reconnect
      };

      startStatusPolling();
    }

    // Event Handlers

    function handleConnected(e) {
      const data = JSON.parse(e.data);
      logMessage('Connected to scan stream', 'success');
    }

    function handlePipelineStarted(e) {
      const data = JSON.parse(e.data);
      logMessage(`Pipeline started: ${data.pipeline_name} v${data.pipeline_version}`, 'info');
      updateLocalStatus("running");

      // Show cancel button when scan is running
      document.getElementById('cancelScanBtn').style.display = 'inline-block';
    }

    function handleStepStart(e) {
      const data = JSON.parse(e.data);
      const stepId = data.step_id;
      const stepKind = data.step_kind;

      steps[stepId] = {
        id: stepId,
        kind: stepKind,
        status: 'running',
        startTime: Date.now()
      };

      updateStepsUI();
      logMessage(`Step started: ${stepId} (${stepKind})`, 'info');
    }

    function handleStepCompleted(e) {
      const data = JSON.parse(e.data);
      const stepId = data.step_id;
      const findingsCount = data.findings_count || 0;
      const duration = data.duration_ms || 0;

      if (steps[stepId]) {
        steps[stepId].status = 'completed';
        steps[stepId].findingsCount = findingsCount;
        steps[stepId].duration = duration;
      }

      updateStepsUI();
      logMessage(`Step completed: ${stepId} (${findingsCount} findings, ${duration}ms)`, 'success');
    }

    function handleStepSkipped(e) {
      const data = JSON.parse(e.data);
      const stepId = data.step_id;
      const reason = data.reason || 'Unknown';

      if (!steps[stepId]) {
        steps[stepId] = { id: stepId, kind: 'unknown', status: 'skipped' };
      } else {
        steps[stepId].status = 'skipped';
      }

      updateStepsUI();
      logMessage(`Step skipped: ${stepId} (${reason})`, 'warning');
    }

    function handleStepFailed(e) {
      const data = JSON.parse(e.data);
      const stepId = data.step_id;
      const error = data.error || 'Unknown error';

      if (steps[stepId]) {
        steps[stepId].status = 'failed';
        steps[stepId].error = error;
      }

      updateStepsUI();
      logMessage(`Step failed: ${stepId} - ${error}`, 'error');
    }

    function handleModelDownloading(e) {
      const data = JSON.parse(e.data);
      const modelId = data.model_id;
      const modelName = data.model_name;
      const progressPct = data.progress_pct || 0;
      const downloadedMb = data.downloaded_mb || 0;
      const totalMb = data.total_mb || 0;
      const speedMbps = data.speed_mbps || 0;
      const fileName = data.file_name || '';

      // Create or update download status in models
      if (!models[modelId]) {
        models[modelId] = {
          id: modelId,
          name: modelName,
          type: 'hf_local',
          device: 'downloading',
          vramUsage: 0,
          loadTime: 0,
          status: 'downloading',
          calls: 0,
          latencies: [],
          findingsCount: 0,
          tokens: { input: 0, output: 0 },
          downloadProgress: progressPct,
          downloadedMb: downloadedMb,
          totalMb: totalMb,
          downloadSpeed: speedMbps
        };
      } else {
        models[modelId].status = 'downloading';
        models[modelId].downloadProgress = progressPct;
        models[modelId].downloadedMb = downloadedMb;
        models[modelId].totalMb = totalMb;
        models[modelId].downloadSpeed = speedMbps;
      }

      updateModelsUI();

      // Log download status
      if (progressPct > 0 && totalMb > 0) {
        logMessage(`Downloading ${modelName}: ${progressPct.toFixed(0)}% (${downloadedMb.toFixed(1)}/${totalMb.toFixed(1)} MB)`, 'info');
      } else if (totalMb > 0) {
        logMessage(`Downloading ${modelName}: ~${totalMb.toFixed(0)} MB`, 'info');
      } else {
        logMessage(`Downloading ${modelName}...`, 'info');
      }
    }

    function handleModelStart(e) {
      const data = JSON.parse(e.data);
      const modelId = data.model_id;
      const modelName = data.model_name;
      const modelType = data.model_type || 'unknown';
      const device = data.device || 'unknown';
      const vramUsage = data.vram_mb || 0;
      const loadTime = data.load_time_ms || 0;

      // Update existing model entry if it was downloading, otherwise create new
      if (models[modelId]) {
        models[modelId].type = modelType;
        models[modelId].device = device;
        models[modelId].vramUsage = vramUsage;
        models[modelId].loadTime = loadTime;
        models[modelId].status = 'running';
        models[modelId].quantization = data.quantization || null;
        models[modelId].precision = data.precision || null;
      } else {
        models[modelId] = {
          id: modelId,
          name: modelName,
          type: modelType,
          device: device,
          vramUsage: vramUsage,
          loadTime: loadTime,
          status: 'running',
          calls: 0,
          latencies: [],
          findingsCount: 0,
          tokens: { input: 0, output: 0 },
          quantization: data.quantization || null,
          precision: data.precision || null
        };
      }

      updateModelsUI();
      logMessage(`Model started: ${modelName} on ${device} (${vramUsage}MB VRAM, loaded in ${loadTime}ms)`, 'info');
    }

    function handleModelCompleted(e) {
      const data = JSON.parse(e.data);
      const modelId = data.model_id;
      const findingsCount = data.findings_count || 0;
      const latency = data.latency_ms || 0;
      const inputTokens = data.input_tokens || 0;
      const outputTokens = data.output_tokens || 0;
      const tokensPerSec = data.tokens_per_sec || 0;

      if (models[modelId]) {
        models[modelId].status = 'completed';
        models[modelId].calls++;
        models[modelId].latencies.push(latency);
        models[modelId].findingsCount += findingsCount;
        models[modelId].tokens.input += inputTokens;
        models[modelId].tokens.output += outputTokens;
        models[modelId].tokensPerSec = tokensPerSec;
      }

      updateModelsUI();
      logMessage(`Model completed: ${modelId} (${latency}ms, ${findingsCount} findings, ${inputTokens + outputTokens} tokens,
${tokensPerSec.toFixed(1)} tok/s)`, 'success');
    }

    function handleProgress(e) {
      const data = JSON.parse(e.data);
      const percent = data.progress_pct || 0;
      const current = data.current || 0;
      const total = data.total || 0;
      const message = data.message || '';

      updateProgressBar(percent, message);

      if (message && message.startsWith("Scanning")) {
        // Debounce logging or just log it
        // To avoid spamming, we can check if it's different from last log?
        // But for now, just log it.
        // Actually, logMessage timestamps it.
        // Let's check if the last log entry is same to avoid duplicate if progress updates generic percent?
        // But message includes filename, so it changes per file.
        // We might get multiple updates per file if chunks?
        // ScanService sends ONE update per file per model.
        logMessage(message, 'info');
      }
    }

    function handleFinding(e) {
      const data = JSON.parse(e.data);
      const finding = data.finding;
      const modelId = data.model_id;

      addFinding(finding, modelId);
      logMessage(`Finding: ${finding.name} (${finding.severity})`, 'warning');
    }

    function handleWarning(e) {
      const data = JSON.parse(e.data);
      const message = data.warning || 'Warning';
      const ctx = data.context || {};
      const details = [];

      if (ctx.model_id) details.push(`model=${ctx.model_id}`);
      if (ctx.file_path) details.push(`file=${ctx.file_path}`);
      if (Array.isArray(ctx.errors) && ctx.errors.length) {
        details.push(`errors=${ctx.errors.join("; ")}`);
      }
      if (ctx.raw_snippet) {
        const snippet = String(ctx.raw_snippet).replace(/\s+/g, ' ').trim();
        details.push(`output="${snippet}"`);
      }

      const suffix = details.length ? ` (${details.join(", ")})` : '';
      logMessage(`${message}${suffix}`, 'warning');
    }

    function handleCompleted(e) {
      const data = JSON.parse(e.data);
      onCompleted(data);
    }

    function handleError(e) {
      const data = JSON.parse(e.data);
      const error = data.error || 'Unknown error';
      onError(error);
    }

    function handleCancelled(e) {
      const data = JSON.parse(e.data);
      const message = data.message || 'Scan cancelled';
      onCancelled(message);
    }

    // Cascade event handlers
    function handleCascadePassStarted(e) {
      const data = JSON.parse(e.data);
      const passNum = data.pass_number || 1;
      const modelsCount = (data.models || []).length;
      const filesCount = data.files_count || 0;
      const description = data.description || `Pass ${passNum}`;

      const stepId = `cascade_pass_${passNum}`;
      steps[stepId] = {
        id: stepId,
        kind: 'cascade_pass',
        status: 'running',
        startTime: Date.now(),
        passNumber: passNum,
        modelsCount: modelsCount,
        filesCount: filesCount
      };

      updateStepsUI();
      logMessage(`Cascade Pass ${passNum} started: ${description} (${modelsCount} models, ${filesCount} files)`, 'info');
    }

    function handleCascadePassCompleted(e) {
      const data = JSON.parse(e.data);
      const passNum = data.pass_number || 1;
      const filesScanned = data.files_scanned || 0;
      const filesFlagged = data.files_flagged || 0;
      const findingsCount = data.findings_count || 0;
      const duration = data.duration_ms || 0;

      const stepId = `cascade_pass_${passNum}`;
      if (steps[stepId]) {
        steps[stepId].status = 'completed';
        steps[stepId].findingsCount = findingsCount;
        steps[stepId].duration = duration;
        steps[stepId].filesScanned = filesScanned;
        steps[stepId].filesFlagged = filesFlagged;
      }

      updateStepsUI();
      const flaggedMsg = passNum === 1 ? `, ${filesFlagged} files flagged` : '';
      logMessage(`Cascade Pass ${passNum} completed: ${findingsCount} findings, ${filesScanned} files${flaggedMsg} (${duration}ms)`, 'success');
    }

    function handleCascadePassSkipped(e) {
      const data = JSON.parse(e.data);
      const passNum = data.pass_number || 2;
      const reason = data.reason || 'No findings to process';

      const stepId = `cascade_pass_${passNum}`;
      if (!steps[stepId]) {
        steps[stepId] = { id: stepId, kind: 'cascade_pass', status: 'skipped' };
      } else {
        steps[stepId].status = 'skipped';
      }
      steps[stepId].skipReason = reason;

      updateStepsUI();
      logMessage(`Cascade Pass ${passNum} skipped: ${reason}`, 'warning');
    }

    function onCompleted(data) {
      if (terminalStatus) {
        return;
      }
      terminalStatus = "completed";
      const totalFindings = data.total_findings || findingsCount || 0;
      const duration = data.duration_ms || 0;

      updateProgressBar(100, 'Completed');
      updateStatusBadge('completed', 'Completed');
      logMessage(`Scan completed: ${totalFindings} findings in ${duration}ms`, 'success');

      // Enable view results button
      document.getElementById('viewResultsBtn').disabled = false;
      document.getElementById('viewResultsBtn').onclick = function () {
        window.location.href = `/scan/${scanId}`;
      };

      // Hide cancel button
      document.getElementById('cancelScanBtn').style.display = 'none';

      // Close SSE connection
      if (eventSource) {
        eventSource.close();
      }

      updateLocalStatus("completed");
      stopStatusPolling();

      // Auto-redirect to results after 2 seconds
      logMessage('Redirecting to results...', 'info');
      setTimeout(() => {
        window.location.href = `/scan/${scanId}`;
      }, 2000);
    }

    function onError(error) {
      if (terminalStatus) {
        return;
      }
      terminalStatus = "failed";
      updateStatusBadge('failed', 'Failed');
      logMessage(`Error: ${error}`, 'error');

      // Hide cancel button
      document.getElementById('cancelScanBtn').style.display = 'none';

      // Close SSE connection
      if (eventSource) {
        eventSource.close();
      }
      updateLocalStatus("failed");
      stopStatusPolling();
    }

    function onCancelled(message) {
      if (terminalStatus) {
        return;
      }
      terminalStatus = "cancelled";
      updateProgressBar(100, 'Cancelled');
      updateStatusBadge('cancelled', 'Cancelled');
      logMessage(`Scan cancelled: ${message}`, 'warning');

      // Hide cancel button
      document.getElementById('cancelScanBtn').style.display = 'none';

      // Close SSE connection
      if (eventSource) {
        eventSource.close();
      }
      updateLocalStatus("cancelled");
      stopStatusPolling();
    }

    // UI Update Functions

    function updateProgressBar(percent, message) {
      const bar = document.getElementById('progressBar');
      const percentSpan = document.getElementById('progressPercent');
      const messageSpan = document.getElementById('progressMessage');
      const timeSpan = document.getElementById('progressTime');

      bar.style.width = `${percent}%`;
      percentSpan.textContent = Math.round(percent);
      if (message) {
        messageSpan.textContent = message;
      }

      const elapsed = Math.floor((Date.now() - startTime) / 1000);
      timeSpan.innerHTML = `Elapsed: <strong>${elapsed}s</strong>`;
    }

    function updateStatusBadge(status, text) {
      const badge = document.getElementById('statusBadge');
      badge.className = `status-badge ${status}`;

      if (status === 'running') {
        badge.innerHTML = '<span class="spinner"></span> ' + text;
      } else if (status === 'completed') {
        badge.innerHTML = '<i class="bi bi-check-circle"></i> ' + text;
      } else if (status === 'failed') {
        badge.innerHTML = '<i class="bi bi-x-circle"></i> ' + text;
      } else if (status === 'cancelled') {
        badge.innerHTML = '<i class="bi bi-slash-circle"></i> ' + text;
      }
    }

    function updateStepsUI() {
      const container = document.getElementById('stepsContainer');
      const stepIds = Object.keys(steps);

      if (stepIds.length === 0) {
        container.innerHTML = '<div class="empty-state"><p>No steps yet</p></div>';
        return;
      }

      container.innerHTML = stepIds.map(stepId => {
        const step = steps[stepId];
        const icon = getStepIcon(step.status);
        const meta = getStepMeta(step);

        return `
<div class="step-indicator">
  <div class="step-icon ${step.status}">
    ${icon}
  </div>
  <div class="step-details">
    <div class="step-name">${stepId}</div>
    <div class="step-meta">${meta}</div>
  </div>
</div>
`;
      }).join('');
    }

    function getStepIcon(status) {
      const icons = {
        pending: '<i class="bi bi-circle"></i>',
        running: '<i class="bi bi-arrow-repeat"></i>',
        completed: '<i class="bi bi-check"></i>',
        failed: '<i class="bi bi-x"></i>',
        skipped: '<i class="bi bi-dash"></i>'
      };
      return icons[status] || icons.pending;
    }

    function getStepMeta(step) {
      if (step.status === 'running') {
        if (step.kind === 'cascade_pass') {
          return `<span class="text-primary">Running... (${step.modelsCount || 0} models, ${step.filesCount || 0} files)</span>`;
        }
        return `<span class="text-primary">Running...</span>`;
      } else if (step.status === 'completed') {
        if (step.kind === 'cascade_pass') {
          const flaggedInfo = step.filesFlagged !== undefined ? `, ${step.filesFlagged} flagged` : '';
          return `Pass ${step.passNumber} | ${step.findingsCount || 0} findings | ${step.filesScanned || 0} files${flaggedInfo} | ${step.duration || 0}ms`;
        }
        return `${step.kind} | ${step.findingsCount || 0} findings | ${step.duration || 0}ms`;
      } else if (step.status === 'skipped') {
        const reason = step.skipReason ? `: ${step.skipReason}` : '';
        return `<span class="text-muted">Skipped${reason}</span>`;
      } else if (step.status === 'failed') {
        return `<span class="text-danger">Failed: ${step.error}</span>`;
      }
      return step.kind;
    }

    function updateModelsUI() {
      const container = document.getElementById('modelsContainer');
      const modelIds = Object.keys(models);

      if (modelIds.length === 0) {
        container.innerHTML = '<div class="empty-state"><p>No model data yet</p></div>';
        return;
      }

      container.innerHTML = modelIds.map(modelId => {
        const model = models[modelId];
        const avgLatency = model.latencies.length > 0
          ? Math.round(model.latencies.reduce((a, b) => a + b, 0) / model.latencies.length)
          : 0;

        const totalTokens = model.tokens.input + model.tokens.output;
        const isHF = model.type && model.type.includes('hf');
        const isCloud = model.type && model.type.includes('cloud');

        let deviceBadge = '';
        if (model.status === 'downloading') {
          deviceBadge = `<span
  class="badge bg-primary bg-opacity-10 text-primary border border-primary border-opacity-25"
  style="font-size: 0.7rem;"><span class="spinner" style="width: 10px; height: 10px; border-width: 1px; margin-right: 4px;"></span>DOWNLOADING</span>`;
        } else if (model.device && model.device !== 'unknown') {
          const deviceColor = model.device.includes('cuda') ? 'success' :
            model.device.includes('mps') ? 'info' :
              'secondary';
          deviceBadge = `<span
  class="badge bg-${deviceColor} bg-opacity-10 text-${deviceColor} border border-${deviceColor} border-opacity-25"
  style="font-size: 0.7rem;">${model.device.toUpperCase()}</span>`;
        }

        let quantBadge = '';
        if (model.quantization) {
          quantBadge = `<span class="badge bg-warning bg-opacity-10 text-warning border border-warning border-opacity-25"
  style="font-size: 0.7rem;">${model.quantization}</span>`;
        }

        let precisionBadge = '';
        if (model.precision) {
          precisionBadge = `<span class="badge bg-info bg-opacity-10 text-info border border-info border-opacity-25"
  style="font-size: 0.7rem;">${model.precision}</span>`;
        }

        return `
<div class="model-panel">
  <div class="model-header">
    <div>
      <span class="model-name">${model.name}</span>
      <div class="mt-1" style="display: flex; gap: 0.25rem; flex-wrap: wrap;">
        ${deviceBadge}
        ${quantBadge}
        ${precisionBadge}
      </div>
    </div>
    <span class="model-status ${model.status}">${model.status}</span>
  </div>
  ${model.status === 'downloading' ? `
  <div class="model-stats" style="flex-direction: column;">
    <div class="mb-2">
      <div class="progress-bar-container" style="height: 6px;">
        <div class="progress-bar-fill" style="width: ${model.downloadProgress || 0}%;"></div>
      </div>
      <div class="d-flex justify-content-between mt-1" style="font-size: 0.75rem; color: var(--text-secondary);">
        <span>${model.downloadProgress ? model.downloadProgress.toFixed(0) + '%' : 'Starting...'}</span>
        ${model.totalMb ? `<span>~${model.totalMb.toFixed(0)} MB</span>` : ''}
      </div>
    </div>
    <div style="font-size: 0.75rem; color: var(--text-secondary);">
      Downloading model weights from Hugging Face Hub...
    </div>
  </div>
  ` : `
  <div class="model-stats" style="grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));">
    <div class="model-stat">
      <span class="model-stat-label">Calls</span>
      <span class="model-stat-value">${model.calls}</span>
    </div>
    <div class="model-stat">
      <span class="model-stat-label">Avg Latency</span>
      <span class="model-stat-value">${avgLatency}ms</span>
    </div>
    <div class="model-stat">
      <span class="model-stat-label">Findings</span>
      <span class="model-stat-value">${model.findingsCount}</span>
    </div>
    ${isHF || isCloud ? `
    <div class="model-stat">
      <span class="model-stat-label">Total Tokens</span>
      <span class="model-stat-value">${totalTokens.toLocaleString()}</span>
    </div>
    ` : ''}
    ${model.tokensPerSec ? `
    <div class="model-stat">
      <span class="model-stat-label">Speed</span>
      <span class="model-stat-value">${model.tokensPerSec.toFixed(1)} tok/s</span>
    </div>
    ` : ''}
    ${model.vramUsage > 0 ? `
    <div class="model-stat">
      <span class="model-stat-label">VRAM</span>
      <span class="model-stat-value">${model.vramUsage}MB</span>
    </div>
    ` : ''}
    ${model.loadTime > 0 ? `
    <div class="model-stat">
      <span class="model-stat-label">Load Time</span>
      <span class="model-stat-value">${model.loadTime}ms</span>
    </div>
    ` : ''}
  </div>
  `}
  ${isHF || isCloud ? `
  <div class="mt-2 pt-2 border-top border-subtle" style="font-size: 0.7rem; color: var(--text-secondary);">
    <div class="d-flex justify-content-between">
      <span>Input: ${model.tokens.input.toLocaleString()} tokens</span>
      <span>Output: ${model.tokens.output.toLocaleString()} tokens</span>
    </div>
  </div>
  ` : ''}
</div>
`;
      }).join('');
    }

    function addFinding(finding, modelId) {
      const container = document.getElementById('findingsContainer');
      const countSpan = document.getElementById('findingsCount');

      // Remove empty state if present
      if (container.querySelector('.empty-state')) {
        container.innerHTML = '';
      }

      findingsCount++;
      countSpan.textContent = findingsCount;

      const findingEl = document.createElement('div');
      findingEl.className = `finding-item severity-${finding.severity || 'medium'}`;
      findingEl.innerHTML = `
<div class="finding-name">${finding.name || 'Unknown Vulnerability'}</div>
<div class="finding-meta">
  ${finding.severity ? `<span class="badge bg-secondary">${finding.severity}</span>` : ''}
  ${finding.cwe ? `<span class="badge bg-secondary">${finding.cwe}</span>` : ''}
  ${finding.file ? `<span class="text-muted ms-2">${finding.file}</span>` : ''}
</div>
`;

      container.insertBefore(findingEl, container.firstChild);

      // Limit to 50 findings in UI
      if (container.children.length > 50) {
        container.removeChild(container.lastChild);
      }
    }

    function logMessage(message, level = 'info') {
      const log = document.getElementById('activityLog');
      const timestamp = new Date().toLocaleTimeString();

      const entry = document.createElement('div');
      entry.className = `log-entry ${level}`;
      entry.innerHTML = `<span class="log-timestamp">${timestamp}</span><span>${message}</span>`;

      log.appendChild(entry);

      // Auto-scroll to bottom
      log.scrollTop = log.scrollHeight;

      // Limit to 100 log entries
      if (log.children.length > 100) {
        log.removeChild(log.firstChild);
      }
    }

    // Update elapsed time every second
    setInterval(() => {
      const timeSpan = document.getElementById('progressTime');
      const elapsed = Math.floor((Date.now() - startTime) / 1000);
      timeSpan.innerHTML = `Elapsed: <strong>${elapsed}s</strong>`;
    }, 1000);

    // Cancel button handler
    document.getElementById('cancelScanBtn').addEventListener('click', async function () {
      if (!confirm('Are you sure you want to cancel this scan?')) {
        return;
      }

      const btn = this;
      btn.disabled = true;
      btn.innerHTML = '<i class="bi bi-hourglass-split"></i> Cancelling...';

      try {
        const response = await fetch(`/api/scan/${scanId}/cancel`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' }
        });

        const data = await response.json();

        if (response.ok) {
          logMessage('Scan cancellation requested', 'warning');
        } else {
          showToast("Error", "Failed to cancel scan: " + (data.error || "Unknown error"), "danger");
          btn.disabled = false;
          btn.innerHTML = '<i class="bi bi-x-circle"></i> Cancel Scan';
        }
      } catch (error) {
        showToast("Error", "Failed to cancel scan: " + error.message, "danger");
        btn.disabled = false;
        btn.innerHTML = '<i class="bi bi-x-circle"></i> Cancel Scan';
      }
    });

    // Initialize on page load
    initSSE();
  })();
</script>
{% endblock %}